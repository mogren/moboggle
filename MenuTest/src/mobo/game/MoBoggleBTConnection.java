package mobo.game;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;

import javax.bluetooth.RemoteDevice;
import javax.microedition.io.StreamConnection;

import games.bt.*;

public class MoBoggleBTConnection implements IGameConnection{

	// TODO: Vad ska det vara för service number???
	protected static final String SERVICE_NBR = "1a88760401bac57a8806abc1ca900010";	/** The service number of the game */
	protected static final BluetoothFacade BTFACADE = new BluetoothFacade();		/** Bluetooth facade instance */

	protected static boolean mAwaitingClient = false;		/** Flag indicating if server is actually awaiting a client */
	protected static boolean mFakeServerClosed = false;		/** Flag indicating if server denies connection once it gets a client */
	protected static boolean mClosed = false;				/** Global server/client connection closed flag */
	protected volatile static StreamConnection mConnection;	/** The server/client StreamConnection */
	protected volatile static DataInputStream mInput;		/** The server/client input stream */
	protected volatile static DataOutputStream mOutput;		/** The server/client output stream */

	public StreamConnection getConnection() throws IOException
	{
		return mConnection;
	}

	public DataInputStream getInput()
	{
		return mInput;
	}

	public DataOutputStream getOutput()
	{
		return mOutput;
	}

	public synchronized boolean isAwaitingClient()
	{
		return mAwaitingClient;
	}

	public synchronized boolean isClosed()
	{
		return mClosed || mFakeServerClosed;
	}

	public synchronized void close() throws IOException
	{
		IOException ioe = null;
		mClosed = true;
		// Close connection
		if (mConnection != null)
		{
			try
			{
				mConnection.close();
				mConnection = null;
			} catch (IOException e)
			{ ioe = e; }
		}
		// Close input stream
		if (mInput != null)
		{
			try
			{
				mInput.close();
				mInput = null;
			} catch (IOException e)
			{ ioe = e; }
		}
		// Close output stream
		if (mOutput != null)
		{
			try
			{
				mOutput.close();
				mOutput = null;
			} catch (IOException e)
			{ ioe = e; }
		}
		// Close server
		try
		{
			BTFACADE.closeServer(SERVICE_NBR);
			mAwaitingClient = false;
		} catch (IOException e)
		{ ioe = e; }

		// Throw exception if we got any
		if (ioe != null)
			throw ioe;
	}

	public boolean connectClient(Object remote) throws IOException
	{
		synchronized(this)
		{
			mClosed = false;
		}
		boolean res = false;
		try
		{
			mConnection = BTFACADE.connect(SERVICE_NBR, (RemoteDevice) remote);
			if (mConnection != null)
			{
				mInput = mConnection.openDataInputStream();
				mOutput = mConnection.openDataOutputStream();
				res = true;
			}
		}
		catch (IOException ioe)
		{
			synchronized(this)
			{
				if (!mClosed)
					throw ioe;	// Not interested in exception if we're closed
			}
		}
		finally
		{
			synchronized(this)
			{
				if (mClosed)
					close();
			}
		}
		return res;
	}

	/**
	 * <p>
	 * Waits for a client, the method blocks until client arrives
	 * or IOException is thrown. The BT server cannot be interrupted - 
	 * call <code>pretendServerClose</code> to emulate this. Any client
	 * that connects after a call to <code>pretendServerClose</code> will
	 * immediately be shutdown.
	 * </p><p>
	 * Disable this state by calling <code>waitForClient</code> again, which
	 * will make the client accepted when it connects. Any call to
	 * <code>waitForClient</code> during an already active client wait will
	 * just set flags and return directly, as there must be another thread still
	 * waiting a client generated by the first call to <code>waitForClient</code>.
	 * <p>
	 */
	public void waitForClient() throws IOException
	{
		synchronized(this)
		{
			if (mAwaitingClient && mFakeServerClosed)
			{
				// Some other thread is still awaiting client,
				// just set flags and return from this call
				mFakeServerClosed = false;
				return;
			}
			mAwaitingClient = true;
			mFakeServerClosed = false;
		}
		try
		{
			// Start listening for client
			mClosed = false;
			mConnection = BTFACADE.waitForClient(SERVICE_NBR);
			mInput = mConnection.openDataInputStream();
			mOutput = mConnection.openDataOutputStream();
		}
		catch (IOException ioe)
		{
			synchronized(this)
			{
				if (!mClosed && !mFakeServerClosed)
					throw ioe;	// Not interested in exception if we're closed
			}
		}
		finally
		{
			synchronized(this)
			{
				// Close connections if some thread closed while we were waiting for client
				mAwaitingClient = false;
				if (mFakeServerClosed)
					close();
			}
		}
	}

	/**
	 * The BT server cannot be interrupted, so lets just
	 * pretend we close the server. If the server gets a client while
	 * in pretended closed mode, or when it time out,
	 * we close connections for real.
	 */
	public synchronized void pretendServerClose()
	{
		mFakeServerClosed = true;
	}

}
